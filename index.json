[{"content":"TLS (Transport Layer Security) ? TLS is a security protocol aimed at enhancing privacy and protecting data during Internet communications. Its primary function is to encrypt communication between web servers and applications, such as when a web browser accesses a website.\nThe Internet Engineering Task Force (IETF), an international standards body, proposed TLS as a means of securing internet communications. TLS 1.0, the first version of the protocol, was released in 1999, and the most recent iteration, TLS 1.3, was published in 2018.\nTLS Vs. SSL? TLS (Transport Layer Security) is based on the SSL (Secure Sockets Layer) protocol, which was developed by Netscape. TLS 1.0 was initially intended to be SSL 3.1, but the name was changed before its release as it no longer had a connection to Netscape. Despite this, the terms TLS and SSL are often used interchangeably.\nTLS and HTTPS? HTTPS is a secure implementation of the TLS encryption protocol, built on top of the HTTP protocol. It is widely used for webservices, APIs, and websites.\nTLS components: Encryption: Hide data being transferred between parties, by encrypting Authentication: Ensures that the parties exchanging information are who they claim to be. Integrity: Verifies that the data has not been forged or tampered with. How TLS works? For a website or application to implement TLS encryption, it must have a TLS certificate installed on its origin server. This certificate, also referred to as an \u0026ldquo;SSL certificate,\u0026rdquo; is issued by a certificate authority (CA) to the domain owner. It contains crucial information about the domain ownership and the server\u0026rsquo;s public key, both of which are necessary for verifying the server\u0026rsquo;s identity.\nThe initiation of a TLS connection is done through a sequence known as the TLS Handshake. When a user accesses a website that utilizes TLS, the TLS Handshake process starts between the user\u0026rsquo;s device, also known as the client device, and the web server.\nTLS handshake:\nSpecify which version of TLS to use (TLS 1.0, 1.2, 1.3, etc.) Decide on which cipher suites to use Authenticate the identity of the server using the server\u0026rsquo;s TLS certificate Generate session keys for encrypting messages between them after the hand The TLS Handshake establishes a cipher suite for the communication session, which is a set of algorithms determining the shared encryption keys or session keys to be used for that specific session.\nThe TLS Handshake makes sure the server is who it says it is by using public keys (Authentication). These public keys allow for secure data exchange and confirm the server\u0026rsquo;s identity. The public key is found in the server\u0026rsquo;s TLS certificate and is used for safe communication\nData is encrypted and verified with a message authentication code (MAC) during a TLS connection. The recipient checks the MAC to make sure the data is unchanged. This is like a seal on a bottle of medicine, showing that it hasn\u0026rsquo;t been tampered with.\nTLS affect web application performance? Recent TLS versions have minimal impact on web application performance. The setup process of a TLS connection requires time and computational resources. The client and server communicate multiple times before data transmission, causing a delay in web application load times and using up client and server memory.\nTechnologies in place that help to mitigate potential latency created by the TLS handshake:\nTLS False Start: Lets the server and client start transmitting data before the TLS handshake is complete. Session Resumption: Allows clients and servers that have previously communicated to use an abbreviated handshake It\u0026rsquo;s always great to share knowledge and educate others about technical topics. I\u0026rsquo;m glad you took the time to read my blog. If you have any questions or feedback, please feel free to reach out. Thanks again for reading! 😊\n","permalink":"https://themayurkumbhar.github.io/post/tls-transport-layer-security/","summary":"TLS (Transport Layer Security) ? TLS is a security protocol aimed at enhancing privacy and protecting data during Internet communications. Its primary function is to encrypt communication between web servers and applications, such as when a web browser accesses a website.\nThe Internet Engineering Task Force (IETF), an international standards body, proposed TLS as a means of securing internet communications. TLS 1.0, the first version of the protocol, was released in 1999, and the most recent iteration, TLS 1.","title":"TLS Transport Layer Security"},{"content":"Recently, I had the chance to work on the proto files for one of my projects to define the contract for a service. Since this was a brand-new service, I had to set it up from scratch and learned how to write and format the proto files using best practices.\nWhat is proto? read more about protocol bufferes\nThere are different tools available for linting the proto files some of them are\nprotoc-gen-lint prototool buf - we have used the buf as a proto linter. Follow this for installation of buf. What is buf? The buf CLI is a tool for working with Protocol Buffers. It has a variety of supported functions such as lint, breaking changes detection, formatter, etc.\nFormat your protos To improve readability and have standard formatting enabled across teams, buf provides the auto-formatting on proto files. This enables the files to be formatted correctly and with following the standards.\nUse the following command to format your files.\nbuf format This will produce any violations in formatting to the console.\nTo auto-format the files in-place with the difference in file changes, use the below command.\nbuf format -w --diff Detect code style checks Linter - A static code analysis used to flag programming errors, bugs, stylistic errors, and suspicious constructs.\nFor proto files, it\u0026rsquo;s no different, to verify the new changes adhere to proto standards use the buf linter.\nbuf lint /path/to/proto/files/ This will produce any errors, warning to console if there are any violations in writing proto files. You can analyze and update the protofiles according to standard rules.\nAutomatically lint with GitLab CI pipeline Whenever there is a change in your repository, your CI pipeline will automatically run buf lint to check for any violations.\nTo check add the below code snippet to the .gitlab-ci.yml\nstages: - lint lint: stage: lint image: name: bufbuild/buf:1.7.0 entrypoint: [\u0026#34;\u0026#34;] script: - buf lint buf configuration rules buf supports three categories of rule configurations.\nMINIMAL BASIC DEFAULT By default, buf has DEFAULT linting configuration which has below details.\nversion: v1 lint: use: - DEFAULT breaking: use: - FILE Use buf mod init to generate DEFAUTL configuration rules for your project.\nYou can update this file with different rules as per the requirements.\nversion: v1 lint: use: - DEFAULT except: - PACKAGE_VERSION_SUFFIX - FIELD_LOWER_SNAKE_CASE - SERVICE_SUFFIX ignore: - google/type/datetime.proto breaking: use: - FILE Hope this article gave understanding of how to use buf tool for formatting, linting your proto files. Happy learning!\n","permalink":"https://themayurkumbhar.github.io/post/linting-proto-files-with-buf/","summary":"Recently, I had the chance to work on the proto files for one of my projects to define the contract for a service. Since this was a brand-new service, I had to set it up from scratch and learned how to write and format the proto files using best practices.\nWhat is proto? read more about protocol bufferes\nThere are different tools available for linting the proto files some of them are","title":"Linting Proto Files With Buf"},{"content":"If you reading this blog means you want to create minimal portfolio or profile without thinking more around designing but should be more professional and small, compact \u0026amp; easy to implement without any setup, learning any new language. If you are the one who don\u0026rsquo;t like to code around HTML tags, CSS files or JS. If you are backend engineer like me 😄 and want good profile page without worrying about the frontend language.\nYou are always welcome to raise pull request to improve this blog.\nGitHub provides each user domain of its github username followed by github.io where your profile is hosted as a website. There are multiple ways you can create your portfolio. You can use any existing framework, language, tools, forking existing repositories and updating as required. This post will focus on how can you write only your portfolio content using markdown and let github take care of rest. Once you have basic repository setup ready you can follow along.\nWhy to use markdown? 🤔 Markdown is most widely used for documentation purpose. Most of developers use this as day to day work in documenting either APIs, WiKi or repository README.md files. This enables best practices and standard structure present in markdown to write portfolio in better format. Also developers are mastered in writing markdown (if you are not, strongly suggest to practice documentations using markdown).\n💡 Quick understanding of MarkDown!\nLet\u0026rsquo;s Get Started - Repositroy Structure Layout 🧱 . ├── Readme.md ├── _config.yml ├── _includes │ ├── about-me.md │ ├── contact.md │ ├── education.md │ ├── posts.md │ └── professional.md ├── index.md └── posts └── getting-started.md Understanding different files in Repository 📚 1. index.md - This is the main file which used as root for the website. When someone hits your profile url this is the first page that gets loaded, which also called as \u0026ldquo;Landing Page\u0026rdquo;\nYou can have a single page website where you can add all the profile data in the same file. Or you can choose the separate the files in multiple folders and update specific sections as and when required. 💡 We will discuss the multiple files approach in this post.\nindex.md file looks like this: --- layout: default #layout style --- {% include file1.md %} {% include file2.md %} {% include file3.md %} Layout part defines which layout to use while rendering index file. Syntax {% raw %}{% include filename.md %}{% endraw %} imports the files in your index file and expands the contents to fit in a single file. github before generating website first imports all the contents and then renders the files conetent as HTML/CSS. 2. _config.yml - This file used to configure the configuration parameters which can be used by the github website generator Jekyll. We will see the some basic required configurations which will enable us to generate the portfolio website.\nconfig file looks like below: title: \u0026lt;Title of your website\u0026gt; description: \u0026lt;discription of your wesite\u0026gt; theme: jekyll-theme-slate #choose theme for your blog relative_links: #true to enable your posts relative paths enabled: true collections: false plugins: - jekyll-relative-links #enable your posts links relative path - jekyll-default-layout #default or create new layout You can select a theme from the list of jekyll themes HERE 💡 This website is generated using a theme called jekyll-theme-slate\n3. _includes - This folder contains all the separate MarkDown files which are part of the portfolios and are broken down to specific contents of file, so they can be modified independently.\nIncludes can contain any kind of data files which are logically separated from each other contents. You can distribute your contents as required in multiple files and then include them as and when required in different files. Example take contact.md file. ## 📇 [Connect with Me!](#contact) ✉️ [mailme@mail.com](mailto:mailme@mail.com) 📱 [+91-1234567890](tel:+911234567890) Then you can include this in your root index.md file. {% include contact.md %} 4. posts - This folder contains all your blog posts which are separated with each new MarkDown file. Once the blog post file is created you need to include that in your posts.md file to publish on your blogs.\nAlways create a new file for each blog, include them only when ready to publish. Example take a blog file getting-started.md: --- layout: default title: Getting Started --- # Getting Started With GitHub Pages in Markdown! **Hello world!**, This is blog post using **Markdown** and **GitHub Pages**. I hope you like it! Conetents of blog post goes here... Now consider our root blogs in posts.md file - We will include getting-started.md in posts.md file so it can be rendered in blogs section of your portfolio. ## Tech Blogs ### [1. Getting Started ](/link/to/posts/getting-started.html) 💡 You can also include diagrams/images/videos/code blocks in your blog.\nSetting up changes in github ⚙️ Once you are ready with your portfolio files, make sure then are committed and pushed to your github repository named \u0026lt;your_github_username\u0026gt;.github.io.\nLet\u0026rsquo;s now set up your special repository to act as a website using github.\nGo to Settings on your repository Select Pages section, which will show you Github Pages Now select drop-down Source and choose master branch to configure \u0026amp; hit save. Wait for a minute or two, you will get the link to your website Boom! Your website is ready!!! 🚀 💡 Bonus Fact: You can include HTML/CSS tags in your MarkDown file to have more control over customizations! 😎\n","permalink":"https://themayurkumbhar.github.io/post/getting-started-with-github-static-pages/","summary":"If you reading this blog means you want to create minimal portfolio or profile without thinking more around designing but should be more professional and small, compact \u0026amp; easy to implement without any setup, learning any new language. If you are the one who don\u0026rsquo;t like to code around HTML tags, CSS files or JS. If you are backend engineer like me 😄 and want good profile page without worrying about the frontend language.","title":"Getting Started With Github Static Pages"},{"content":"Work Experience ⚙️ GoJek Tech 🛵💳 🖥️ Software Developer December 2021 - Current Enabling high scale payments experience with distributed systems.\nBarclays PLC 💳 🖥️ Senior Software Developer July 2017 - December 2021 Delivering rewards capabilities to customers, enhancing customer experience, designing and implementing new requirements, maintaining resilient services with high availability, Working on cloud-native, distributed, event driven REST micro-services.\nVeritas LLC ☁️ 🖥️ Software Engineering Intern Jan 2017 - Jun 2017 Enabling high standard configurable product tool to help optimize product configuration time.\nEducation 🎓 🧑‍🎓 Birla Institute of Technology and Science, Pilani M.Tech Computer Engineering July 2021 - Persuing 🎓 Walchand College Of Engineering, Sangli B.Tech Computer Science and Engineering July 2013 - May 2017 ","permalink":"https://themayurkumbhar.github.io/about/","summary":"Work Experience ⚙️ GoJek Tech 🛵💳 🖥️ Software Developer December 2021 - Current Enabling high scale payments experience with distributed systems.\nBarclays PLC 💳 🖥️ Senior Software Developer July 2017 - December 2021 Delivering rewards capabilities to customers, enhancing customer experience, designing and implementing new requirements, maintaining resilient services with high availability, Working on cloud-native, distributed, event driven REST micro-services.\nVeritas LLC ☁️ 🖥️ Software Engineering Intern Jan 2017 - Jun 2017 Enabling high standard configurable product tool to help optimize product configuration time.","title":"About Mayur"},{"content":" 📝 Mayur\u0026rsquo;s LinkedIn ✉️ mayur.kumbhar@outlook.com 📱 +91-9096591857 📄 Resume This profile is self-sufficient to know about me 😜. But still if you need the profile copy, you can get HERE!\n","permalink":"https://themayurkumbhar.github.io/contact/","summary":"📝 Mayur\u0026rsquo;s LinkedIn ✉️ mayur.kumbhar@outlook.com 📱 +91-9096591857 📄 Resume This profile is self-sufficient to know about me 😜. But still if you need the profile copy, you can get HERE!","title":"Contact"}]